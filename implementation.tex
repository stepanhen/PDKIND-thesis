\chapter{Implementation}
\noindent In this chapter, we will refer to the description of the PDKind algorithm, analyze it and modify it to fit our implementation.

\section{Reachability checking procedure}
The reachability procedure, shownm in \ref{alg:1} is a procedure, which determines whether a given state is reachable in a specific number of steps from a set of initial states. This check is completed using a depth-first search (DFS) strategy, along with other methods and data structures that need to be analyzed to ensure correctness and efficiency in our implementation.

The choice of depth-first search (DFS) in this procedure balances efficiency and memory usage. While DFS minimizes memory overhead compared to breadth-first search (BFS), it may explore deeper infeasible paths first, potentially increasing runtime in cases where a shallower counterexample exists.

The above mentioned methods and data structures, that need analysis are: \textbf{Satisfiability checking}, \textbf{Generalization}, \textbf{Explanation} and \textbf{Reachability frames representation}.
\section*{Satisfiability Checking}
\noindent We could use various SMT solvers for satisfiability checking, including Z3\cite{}, CVC5\cite{}, or OpenSMT\cite{OpenSMT}, with each solver having different strengths in terms of efficiency, theory support, or integration capabilities.

Since Golem already provides a wrapper around the OpenSMT solver and uses it for satisfiability checking in every other engine, we also chose it for our implementation. This choice maintains consistency across the whole project and avoids problems of integrating a new solver into the project.

Another reason for using OpenSMT is that since it is used in all other Golem engines, it provides a fair performance comparison of these engines with our PDKind engine. Using a different SMT solver in our implementation could give our engine an advantage or a disadvantage in terms of efficiency. By using OpenSMT, we ensure that these possibilities are isolated and that the observed performance differences would come mainly from algorithmic strength rather than solver efficiency.

Furthermore, OpenSMT provides utilities that are very important for our engine. One of them is providing models for satisfiability checks, and the other is the ability to generate interpolants. Since interpolation is used to strengthen inductive invariants, utilizing these features eliminates the need for additional mechanism implementation. While other SMT solvers may offer similar capabilities, choosing OpenSMT is the most convenient and efficient choice for our implementation.

\section*{Generalization}

\noindent Generalization plays an essential role in PDKind by preventing redundant checks and improving abstraction. It ensures that the algorithm abstracts wider state representation rather than handling individual states separately. However, Golem does not provide a built-in generalization method.

Still, it has needed components to create our method, as shown in pseudocode Algorithm \ref{alg:2}. The method uses the KeepOnly function to eliminate all non-state variables from the formula \( T[B]^k(\vec{x}, \vec{w}, \vec{y}) \wedge C(\vec{y}) \), retaining only the state variables $\vec{x}$. We will show that this approach satisfies the generalization definition \ref{generalization}.

\begin{figure}[H]
    \begin{mdframed}
        \begin{algorithmic}[1]
            \State \textbf{Input:} Model $M$, transition formula $T$, state formula $F$
            \State \textbf{Output:} Generalized formula $G$

            \State $StateVars \gets$ GetStateVars()
            \State $G \gets$ KeepOnly(StateVars, $T \wedge F$, $M$)
            \State \Return $G$

        \end{algorithmic}
    \end{mdframed}
    \caption{Generalize method}\label{alg:2}
\end{figure}

\subsection*{Relationship between $M$, $T$ and $F$}
\noindent In algorithm \ref{alg:2}, we use three formulas:
\begin{itemize}
    \item \textbf{$T$ (Transition formula)}: Defines the evolution of states over time.
    \item \textbf{$F$ (State formula)}: Represents the state that we are analyzing.
    \item \textbf{$M$ (Model)}: A satisfying assignment to formula $T \land F$ that provides an example of a state transition.
\end{itemize}

Given a model $M$, our goal is to abstract it into a formula $G$ that describes a wider set of possible states.

\subsection*{KeepOnly method}
The KeepOnly method extracts only the state variables from $T \land G$ by removing all the auxiliary variables, such as the intermediate states $\vec{w}$ and the successor states $\vec{y}$ from definition \ref{generalization}. This approach ensures that the generalized formula $G$ depends only on the current state $\vec{x}$, which makes the formula $G(\vec{x})$ an over-approximation as it represents all possible states that satisfy $T \land F$ rather than just the single assignment given by model $M$.

\subsection*{Satisfying the Generalization Definition}
To confirm that Algorithm \ref{alg:2} correctly implements generalization, we check the two required properties:


1. \textbf{Over-approximation}:
- By removing $\vec{w}, \vec{y}$, we ensure that $G(\vec{x})$ captures all possible satisfying assignments for the transition relation $T$ and condition $F$.
- This directly satisfies the first condition of the generalization definition \ref{generalization}.

2. \textbf{Consistency with Initial States $A(\vec{x})$}:
- Since we only eliminate intermediate variables and do not introduce new constraints, $G(\vec{x})$ remains consistent with the original set of reachable states.
- This ensures that $G(\vec{x})$ does not eliminate any valid states from consideration.

Thus, algorithm \ref{alg:2} produces a valid and useful generalization for PDKind.

\section*{Explanation} \label{Explain}
\noindent Instead of implementing a custom \( Explain() \) method, we utilize the OpenSMT solver feature, which is an interpolation. To obtain the interpolant, we tell the solver to compute an interpolation of the first two formulas inserted in it. For example, given a satisfiability check $CheckSat(A \land B \land C)$, we want an interpolant of $A \land B$.

Interpolation is useful here because it provides a formula that separates $A \land B$ from $C$, ensuring that the learned constraints eliminate infeasible states without being too restrictive.

On line 13 in Algorithm \ref{alg:1}, we require an interpolant from the \( CheckSAT() \) call that occurred in the previous \( Reachable() \) call. To support this behavior, we modify our \( Reachable() \) method on line 17 to return an interpolant along with the \( false \) result when a check fails. Since interpolation is only defined when the formula is unsatisfiable, we only request an interpolant if \( CheckSAT() \) returns \( false \).

In our implementation, each \( CheckSAT() \) is performed using a separate solver instance. This means obtaining an interpolant is simple; we instruct the solver instance to return the interpolant generated from its internal state, reflecting the formulas used in the failed check.

\section*{Reachability frames representation}\label{RFrames}
\noindent For the \( Reachability frames \) representation, we had several choices. The simplest approach was to create a list $R$ of formulas, where each frame is stored as $R_i := R[i]$. Each time we call \( Reachable() \) from outside, we would construct a new list of reachability frames.

While this method is straightforward, it is inefficient because it discards previously computed frames with each call, preventing reuse and requiring redundant computation. Instead, we create a more efficient approach by making a \( Reachability \) class.

Each instance of the \( Reachability \) class  maintains a persistent list of frames, where calling \( Reachable() \) on that instance extends the existing reachability frames instead of discarding them. This allows us to reuse previously computed information across multiple calls, improving efficiency and reducing unnecessary recomputation.

\section*{Push}
We already mentioned that the OpenSMT\cite{OpenSMT} has the option to provide a model after successful satisfiability check.
We can notice that the \texttt{CheckSAT}
call returns model \texttt{m\_1}. In our implementation, \texttt{CheckSAT}
doesn't directly return model, but we can ask the solver to provide one. This
is done by initializing a new solver instance for each check and then asking
for a model, if the check is true.

On line 19, we can see that \texttt{Reachable()} accepts more arguments and
returns more values than shown in Algorithm
\ref{alg:1}. This new
\texttt{Reachable($i$,$j$,$F$)} method checks if $F$ is reachable in k steps
where $i\leq k \leq j$. To achieve this behavior in our implementation, we
create a wrapper function that calls \texttt{Reachable($k$, $F$)} in a for loop
and returns the first \texttt{k} where the call was successful along with the
result. The \texttt{i} return value is an interpolant of the last
\texttt{Reachable()} check if the whole check wasn't successful.

\section*{PDKind}
In our implementation, the property \( P \) is a negation of a query, that
we get on the input, which represents bad states. We also need to check if the
initial states are empty, which would result in \( SAFE \), or if the query
holds in the initial states, which would result in \( UNSAFE \).

\section{Validity checking}
\noindent In many cases, it is often required to provide a witness to the
answer obtained from solving the CHC satisfiability problem. In software
verification, a satisfiability witness corresponds to a program invariant, and
an unsatisfiability witness corresponds to counterexample paths. Generally, a
satisfiability witness is a model that provides an interpretation of all CHC
predicates and variables that satisfy all the clauses. An unsatisfiability
witness is a proof presented as a sequence of derivations of ground instances
of the predicates, where for the proof to be valid, each premise must be a
conclusion of some previously derived step.

In Golem \cite{blicha_golem_2023}, each engine provides a validity witness when
the option \texttt{--print-witness} is used. To follow the structure Golem has,
we need to implement such an option for our PDKind engine as well.

\section*{UNSAT witness} \label{UNSATWit}
\noindent First, we will describe the implementation of the unsatisfiability
witness in our engine. The goal is to generate paths to counterexamples during
the CHC satisfiability solving process.

To do that, we utilize a function in the Golem solver, which can generate the
path to a counterexample based on the number of steps required to reach the
counterexample, for clarity, we will call them \texttt{steps to the
counterexample}. This allows us to only keep track of the \texttt{steps to a
counterexample} for each potential counterexample we encounter during the CHC
solving. The \texttt{steps to a counterexample} of a potential counterexample
is a number of steps needed to reach the counterexample from the potential
counterexample. To do this, we take the \texttt{Induction frame}
\texttt{(lemma, counterExample)} and create a structure for the
\texttt{counterExample}, which will hold the formula and the \texttt{steps to a
counterxample}.

In the next step, we need to correctly assign the \texttt{steps to a
counterexample} to each counterexample, that we find. In Algorithm
\ref{alg:3}, we note that a new counterexample
\texttt{g\_2} is created only on line 18, which we then use in the else branch
starting on line 23. The \texttt{steps to a counterexample} assigned to
\texttt{g\_2} is the \texttt{steps to a counterexample} of
\texttt{counterExample} increased by \texttt{k}.

Finally, we need to modify \texttt{Push()} to return the \texttt{steps to a
counterexample}. On line 21, when we encounter a reachable counterexample
\texttt{g\_2}, we assign the \texttt{steps to a counterexample} returned by
\texttt{Push()} to be the \texttt{steps to a counterexample} of \texttt{g\_2}.

\section*{SAT witness}
\noindent In this section, we will describe the implementation of the
satisfiability witness in the PDKind engine. The aim is to construct an
inductive invariant during the CHC satisfiability solving process.

In the \texttt{Push()} procedure described in Algorithm
\ref{alg:3}, we are constructing an \texttt{Induction
Frame}, which is a set of tuples \texttt{(lemma, counterExample)}, where the
\texttt{lemma} holds for \texttt{n} steps and refutes the
\texttt{counterExample}. After the solving procedure is finished, we end up on
line 12 of the PDKind procedure in Algorithm \ref{alg:4}
because we are constructing the satisfiability
witness. We can then take the final \texttt{Induction Frame} and form a
conjunction of all the lemmas within it. This gives us an n-inductive
invariant, as the lemmas hold for \texttt{n} steps, and there is no other
strengthening of the \texttt{Induction Frame}, as indicated by \( F = G \) at
line 11.

The final step is to transform the n-inductive invariant into an inductive
invariant. To do that, we utilize the Golem solver's function
\texttt{kinductiveToInductive()}, which takes the n-inductive invariant,
\texttt{n}, and the system and returns an inductive invariant. This invariant
is the validity witness for the \texttt{SAT} answer.

