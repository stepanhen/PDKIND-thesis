\chapter{Implementation}
\noindent In this chapter, we will refer to the description of the PDKind algorithm, analyze it and modify it to fit our implementation.

In our implementation, we needed to analyze the following parts of the algorithm to be able to implement it: \textbf{Satisfiability checking}, \textbf{Generalization}, \textbf{Explanation} and \textbf{Reachability frames representation}.
The choice of depth-first search (DFS) in this procedure balances efficiency and memory usage. While DFS minimizes memory overhead compared to breadth-first search (BFS), it may explore deeper infeasible paths first, potentially increasing runtime in cases where a shallower counterexample exists.
\section*{Satisfiability Checking}
\noindent We could use various SMT solvers for satisfiability checking, but Golem already has a wrapper around the OpenSMT solver and uses it in every other engine. Therefore we will use it too for every other satisfiability check, that we will need.

\section*{Generalization}
\noindent Golem doesn't provide us with the generalization method. Still, it has needed components to create our method, as shown in pseudocode Algorithm \ref{alg:2}. It eliminates all variables except the state ones, represented as $\vec{x}$ from the formula \( T[B]^k(\vec{x}, \vec{w}, \vec{y}) \wedge C(\vec{y}) \) to satisfy the generalization definition.
\begin{figure}[H]
    \begin{mdframed}
        \begin{algorithmic}[1]
            \State \textbf{Input:} Model $M$, transition formula $T$, state formula $F$
            \State \textbf{Output:} Generalized formula $G$

            \State $StateVars \gets$ GetStateVars()
            \State $G \gets$ KeepOnly(StateVars, $T \wedge F$, $M$)
            \State \Return $G$

        \end{algorithmic}
    \end{mdframed}
    \caption{Generalize method}\label{alg:2}
\end{figure}

\section*{Explanation} \label{Explain}
\noindent Instead of the \texttt{Explain()} method, we will use another feature of the OpenSMT solver and that is interpolation. To get the interpolant, we tell the solver to give us an interpolation of the first two formulas inserted in it, i.e. for \texttt{CheckSat($A \wedge B \wedge C$)} we want interpolation of $A \wedge B$.

On line 13 in Algorithm \ref{alg:1}, we need an interpolant from the \texttt{CheckSAT()} that happened in the previous \texttt{Reachable()} call. Therefore, we need to modify our \texttt{Reachable()} method on line 17 to also return an interpolant along with the false result. Later, we will see that in our implementation each \texttt{CheckSAT()} has its solver instance. To get the interpolant, we just ask the solver to return it if the \texttt{CheckSAT()} fails.

\section*{Reachability frames representation}\label{RFrames}
\noindent For the \texttt{Reachability frames} representation, we had several choices. The simplest one was to create a list $R$ of formulas (where $R_i := R[i]$) each time we call \texttt{Reachable()} from outside. This approach is simple, yet not efficient since we would be losing the whole \texttt{Reachability frames} we built in each call, instead of reusing it in another call.

Therefore, we will create a better approach and that is a \texttt{Reachability} class, where each instance of this class will hold such list, but calling \texttt{Reachable()} on that instance would only grow the \texttt{Reachability frames} and wouldn't delete it.

%PUSH
\section*{Push}
We can notice that the \texttt{CheckSAT}
call returns model \texttt{m\_1}. In our implementation, \texttt{CheckSAT}
doesn't directly return model, but we can ask the solver to provide one. This
is done by initializing a new solver instance for each check and then asking
for a model, if the check is true.

On line 19, we can see that \texttt{Reachable()} accepts more arguments and
returns more values than shown in Algorithm
\ref{alg:1}. This new
\texttt{Reachable($i$,$j$,$F$)} method checks if $F$ is reachable in k steps
where $i\leq k \leq j$. To achieve this behavior in our implementation, we
create a wrapper function that calls \texttt{Reachable($k$, $F$)} in a for loop
and returns the first \texttt{k} where the call was successful along with the
result. The \texttt{i} return value is an interpolant of the last
\texttt{Reachable()} check if the whole check wasn't successful.

\section*{PDKind}
In our implementation, the property \( P \) is a negation of a query, that
we get on the input, which represents bad states. We also need to check if the
initial states are empty, which would result in \( SAFE \), or if the query
holds in the initial states, which would result in \( UNSAFE \).

\section{Validity checking}
\noindent In many cases, it is often required to provide a witness to the
answer obtained from solving the CHC satisfiability problem. In software
verification, a satisfiability witness corresponds to a program invariant, and
an unsatisfiability witness corresponds to counterexample paths. Generally, a
satisfiability witness is a model that provides an interpretation of all CHC
predicates and variables that satisfy all the clauses. An unsatisfiability
witness is a proof presented as a sequence of derivations of ground instances
of the predicates, where for the proof to be valid, each premise must be a
conclusion of some previously derived step.

In Golem \cite{blicha_golem_2023}, each engine provides a validity witness when
the option \texttt{--print-witness} is used. To follow the structure Golem has,
we need to implement such an option for our PDKind engine as well.

\section*{UNSAT witness} \label{UNSATWit}
\noindent First, we will describe the implementation of the unsatisfiability
witness in our engine. The goal is to generate paths to counterexamples during
the CHC satisfiability solving process.

To do that, we utilize a function in the Golem solver, which can generate the
path to a counterexample based on the number of steps required to reach the
counterexample, for clarity, we will call them \texttt{steps to the
counterexample}. This allows us to only keep track of the \texttt{steps to a
counterexample} for each potential counterexample we encounter during the CHC
solving. The \texttt{steps to a counterexample} of a potential counterexample
is a number of steps needed to reach the counterexample from the potential
counterexample. To do this, we take the \texttt{Induction frame}
\texttt{(lemma, counterExample)} and create a structure for the
\texttt{counterExample}, which will hold the formula and the \texttt{steps to a
counterxample}.

In the next step, we need to correctly assign the \texttt{steps to a
counterexample} to each counterexample, that we find. In Algorithm
\ref{alg:3}, we note that a new counterexample
\texttt{g\_2} is created only on line 18, which we then use in the else branch
starting on line 23. The \texttt{steps to a counterexample} assigned to
\texttt{g\_2} is the \texttt{steps to a counterexample} of
\texttt{counterExample} increased by \texttt{k}.

Finally, we need to modify \texttt{Push()} to return the \texttt{steps to a
counterexample}. On line 21, when we encounter a reachable counterexample
\texttt{g\_2}, we assign the \texttt{steps to a counterexample} returned by
\texttt{Push()} to be the \texttt{steps to a counterexample} of \texttt{g\_2}.

\section*{SAT witness}
\noindent In this section, we will describe the implementation of the
satisfiability witness in the PDKind engine. The aim is to construct an
inductive invariant during the CHC satisfiability solving process.

In the \texttt{Push()} procedure described in Algorithm
\ref{alg:3}, we are constructing an \texttt{Induction
Frame}, which is a set of tuples \texttt{(lemma, counterExample)}, where the
\texttt{lemma} holds for \texttt{n} steps and refutes the
\texttt{counterExample}. After the solving procedure is finished, we end up on
line 12 of the PDKind procedure in Algorithm \ref{alg:4}
because we are constructing the satisfiability
witness. We can then take the final \texttt{Induction Frame} and form a
conjunction of all the lemmas within it. This gives us an n-inductive
invariant, as the lemmas hold for \texttt{n} steps, and there is no other
strengthening of the \texttt{Induction Frame}, as indicated by \( F = G \) at
line 11.

The final step is to transform the n-inductive invariant into an inductive
invariant. To do that, we utilize the Golem solver's function
\texttt{kinductiveToInductive()}, which takes the n-inductive invariant,
\texttt{n}, and the system and returns an inductive invariant. This invariant
is the validity witness for the \texttt{SAT} answer.

