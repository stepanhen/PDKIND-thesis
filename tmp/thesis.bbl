% $ biblatex auxiliary file $
% $ biblatex bbl format version 3.2 $
% Do not modify the above lines!
%
% This is an auxiliary file used by the 'biblatex' package.
% This file may safely be deleted. It will be recreated by
% biber as required.
%
\begingroup
\makeatletter
\@ifundefined{ver@biblatex.sty}
  {\@latex@error
     {Missing 'biblatex' package}
     {The bibliography requires the 'biblatex' package.}
      \aftergroup\endinput}
  {}
\endgroup


\refsection{0}
  \datalist[entry]{nty/global//global/global}
    \entry{BarFT-SMTLIB}{misc}{}
      \name{author}{3}{}{%
        {{hash=f519b0ade21460e17b744091e47a6c39}{%
           family={Barrett},
           familyi={B\bibinitperiod},
           given={Clark},
           giveni={C\bibinitperiod}}}%
        {{hash=7ffa3c8daa982fea0c4416306e4f999a}{%
           family={Fontaine},
           familyi={F\bibinitperiod},
           given={Pascal},
           giveni={P\bibinitperiod}}}%
        {{hash=17736d07fc9708df7a9802ea0d682814}{%
           family={Tinelli},
           familyi={T\bibinitperiod},
           given={Cesare},
           giveni={C\bibinitperiod}}}%
      }
      \strng{namehash}{9a8b3d2318c82054c673038cd8ce075a}
      \strng{fullhash}{fc9ee783669002ba5f19ab8838304294}
      \strng{bibnamehash}{fc9ee783669002ba5f19ab8838304294}
      \strng{authorbibnamehash}{fc9ee783669002ba5f19ab8838304294}
      \strng{authornamehash}{9a8b3d2318c82054c673038cd8ce075a}
      \strng{authorfullhash}{fc9ee783669002ba5f19ab8838304294}
      \field{sortinit}{B}
      \field{sortinithash}{d7095fff47cda75ca2589920aae98399}
      \field{labelnamesource}{author}
      \field{labeltitlesource}{title}
      \field{howpublished}{{\tt www.SMT-LIB.org}}
      \field{title}{{The Satisfiability Modulo Theories Library (SMT-LIB)}}
      \field{year}{2016}
    \endentry
    \entry{10.1007/3-540-49059-0_14}{inproceedings}{}
      \name{author}{4}{}{%
        {{hash=22081d00e30965a89f413e528510617e}{%
           family={Biere},
           familyi={B\bibinitperiod},
           given={Armin},
           giveni={A\bibinitperiod}}}%
        {{hash=a5b10079891f6f21fb73ad9931f3ea4b}{%
           family={Cimatti},
           familyi={C\bibinitperiod},
           given={Alessandro},
           giveni={A\bibinitperiod}}}%
        {{hash=76fe4736f1859a02499e11e8122c3d3b}{%
           family={Clarke},
           familyi={C\bibinitperiod},
           given={Edmund},
           giveni={E\bibinitperiod}}}%
        {{hash=a9c1f54328aafe25c651beb2bebb66f6}{%
           family={Zhu},
           familyi={Z\bibinitperiod},
           given={Yunshan},
           giveni={Y\bibinitperiod}}}%
      }
      \name{editor}{1}{}{%
        {{hash=63b529bd029b79e24b33823e2fb3c812}{%
           family={Cleaveland},
           familyi={C\bibinitperiod},
           given={W.\bibnamedelimi Rance},
           giveni={W\bibinitperiod\bibinitdelim R\bibinitperiod}}}%
      }
      \list{location}{1}{%
        {Berlin, Heidelberg}%
      }
      \list{publisher}{1}{%
        {Springer Berlin Heidelberg}%
      }
      \strng{namehash}{bc3be1691d20d567b9af500e799dfef0}
      \strng{fullhash}{10b1d48fbca575e7d9ff3c676f532f6c}
      \strng{bibnamehash}{10b1d48fbca575e7d9ff3c676f532f6c}
      \strng{authorbibnamehash}{10b1d48fbca575e7d9ff3c676f532f6c}
      \strng{authornamehash}{bc3be1691d20d567b9af500e799dfef0}
      \strng{authorfullhash}{10b1d48fbca575e7d9ff3c676f532f6c}
      \strng{editorbibnamehash}{63b529bd029b79e24b33823e2fb3c812}
      \strng{editornamehash}{63b529bd029b79e24b33823e2fb3c812}
      \strng{editorfullhash}{63b529bd029b79e24b33823e2fb3c812}
      \field{sortinit}{B}
      \field{sortinithash}{d7095fff47cda75ca2589920aae98399}
      \field{labelnamesource}{author}
      \field{labeltitlesource}{title}
      \field{abstract}{Symbolic Model Checking [3], [14] has proven to be a powerful technique for the verification of reactive systems. BDDs [2] have traditionally been used as a symbolic representation of the system. In this paper we show how boolean decision procedures, like St{Ã¥}lmarck's Method [16] or the Davis {\&} Putnam Procedure [7], can replace BDDs. This new technique avoids the space blow up of BDDs, generates counterexamples much faster, and sometimes speeds up the verification. In addition, it produces counterexamples of minimal length. We introduce a bounded model checking procedure for LTL which reduces model checking to propositional satisfiability.We show that bounded LTL model checking can be done without a tableau construction. We have implemented a model checker BMC, based on bounded model checking, and preliminary results are presented.}
      \field{booktitle}{Tools and Algorithms for the Construction and Analysis of Systems}
      \field{isbn}{978-3-540-49059-3}
      \field{title}{Symbolic Model Checking without BDDs}
      \field{year}{1999}
      \field{pages}{193\bibrangedash 207}
      \range{pages}{15}
    \endentry
    \entry{blicha_golem_2023}{inproceedings}{}
      \name{author}{3}{}{%
        {{hash=28666c2119f9a5a8a718cfe5ff8d8b5c}{%
           family={Blicha},
           familyi={B\bibinitperiod},
           given={Martin},
           giveni={M\bibinitperiod}}}%
        {{hash=3e80993f2b37fecc592930b0a392824c}{%
           family={Britikov},
           familyi={B\bibinitperiod},
           given={Konstantin},
           giveni={K\bibinitperiod}}}%
        {{hash=1f57d7602abbd1e09505b9760b4a5a8b}{%
           family={Sharygina},
           familyi={S\bibinitperiod},
           given={Natasha},
           giveni={N\bibinitperiod}}}%
      }
      \name{editor}{2}{}{%
        {{hash=077e76ee36a8b1e0435b135cf7ef3ab5}{%
           family={Enea},
           familyi={E\bibinitperiod},
           given={Constantin},
           giveni={C\bibinitperiod}}}%
        {{hash=19cc21879ace6ed5c1aa22d68a36116a}{%
           family={Lal},
           familyi={L\bibinitperiod},
           given={Akash},
           giveni={A\bibinitperiod}}}%
      }
      \list{location}{1}{%
        {Cham}%
      }
      \list{publisher}{1}{%
        {Springer Nature Switzerland}%
      }
      \strng{namehash}{b69e5ced8d7d6b64dd60f63dddb1f0c4}
      \strng{fullhash}{ad879c26518ffa8ad46c23219cc81f4f}
      \strng{bibnamehash}{ad879c26518ffa8ad46c23219cc81f4f}
      \strng{authorbibnamehash}{ad879c26518ffa8ad46c23219cc81f4f}
      \strng{authornamehash}{b69e5ced8d7d6b64dd60f63dddb1f0c4}
      \strng{authorfullhash}{ad879c26518ffa8ad46c23219cc81f4f}
      \strng{editorbibnamehash}{96c931708131e8ab4bfccea34aaf2250}
      \strng{editornamehash}{96c931708131e8ab4bfccea34aaf2250}
      \strng{editorfullhash}{96c931708131e8ab4bfccea34aaf2250}
      \field{sortinit}{B}
      \field{sortinithash}{d7095fff47cda75ca2589920aae98399}
      \field{labelnamesource}{author}
      \field{labeltitlesource}{title}
      \field{booktitle}{{Computer Aided Verification}}
      \field{isbn}{978-3-031-37703-7}
      \field{series}{{Lecture Notes in Computer Science}}
      \field{title}{{The Golem Horn Solver}}
      \field{year}{2023}
      \field{pages}{209\bibrangedash 223}
      \range{pages}{15}
      \verb{doi}
      \verb 10.1007/978-3-031-37703-7_10
      \endverb
    \endentry
    \entry{10.1007/978-3-642-12002-2_12}{inproceedings}{}
      \name{author}{4}{}{%
        {{hash=23e7990cbc8cb24a8a85096836d2d2cb}{%
           family={Bruttomesso},
           familyi={B\bibinitperiod},
           given={Roberto},
           giveni={R\bibinitperiod}}}%
        {{hash=cd459eeb138932497562fbcc5cecf07d}{%
           family={Pek},
           familyi={P\bibinitperiod},
           given={Edgar},
           giveni={E\bibinitperiod}}}%
        {{hash=1f57d7602abbd1e09505b9760b4a5a8b}{%
           family={Sharygina},
           familyi={S\bibinitperiod},
           given={Natasha},
           giveni={N\bibinitperiod}}}%
        {{hash=b8ca03f8c23548ff178c3d19dd29f216}{%
           family={Tsitovich},
           familyi={T\bibinitperiod},
           given={Aliaksei},
           giveni={A\bibinitperiod}}}%
      }
      \name{editor}{2}{}{%
        {{hash=aae57fe3f3726fcbced8c287c38380ec}{%
           family={Esparza},
           familyi={E\bibinitperiod},
           given={Javier},
           giveni={J\bibinitperiod}}}%
        {{hash=78643650cab303170e95fbd8ac71e624}{%
           family={Majumdar},
           familyi={M\bibinitperiod},
           given={Rupak},
           giveni={R\bibinitperiod}}}%
      }
      \list{location}{1}{%
        {Berlin, Heidelberg}%
      }
      \list{publisher}{1}{%
        {Springer Berlin Heidelberg}%
      }
      \strng{namehash}{4d48136b1b7f37909ab46de26601196b}
      \strng{fullhash}{0f66bf469a77ed368ed348ea2db7223e}
      \strng{bibnamehash}{0f66bf469a77ed368ed348ea2db7223e}
      \strng{authorbibnamehash}{0f66bf469a77ed368ed348ea2db7223e}
      \strng{authornamehash}{4d48136b1b7f37909ab46de26601196b}
      \strng{authorfullhash}{0f66bf469a77ed368ed348ea2db7223e}
      \strng{editorbibnamehash}{d384956a2f1c1bd5b626a1fc386ba8f1}
      \strng{editornamehash}{d384956a2f1c1bd5b626a1fc386ba8f1}
      \strng{editorfullhash}{d384956a2f1c1bd5b626a1fc386ba8f1}
      \field{sortinit}{B}
      \field{sortinithash}{d7095fff47cda75ca2589920aae98399}
      \field{labelnamesource}{author}
      \field{labeltitlesource}{title}
      \field{abstract}{This paper describes OpenSMT, an incremental, efficient, and open-source SMT-solver. OpenSMT has been specifically designed to be easily extended with new theory-solvers, in order to be accessible for non-experts for the development of customized algorithms. We sketch the solver's architecture and interface. We discuss its distinguishing features w.r.t. other state-of-the-art solvers.}
      \field{booktitle}{Tools and Algorithms for the Construction and Analysis of Systems}
      \field{isbn}{978-3-642-12002-2}
      \field{title}{The OpenSMT Solver}
      \field{year}{2010}
      \field{pages}{150\bibrangedash 153}
      \range{pages}{4}
    \endentry
    \entry{10.1145/800157.805047}{inproceedings}{}
      \name{author}{1}{}{%
        {{hash=609a39905dc0e988c3b294dceecdb1e4}{%
           family={Cook},
           familyi={C\bibinitperiod},
           given={Stephen\bibnamedelima A.},
           giveni={S\bibinitperiod\bibinitdelim A\bibinitperiod}}}%
      }
      \list{location}{1}{%
        {Shaker Heights, Ohio, USA}%
      }
      \list{publisher}{1}{%
        {Association for Computing Machinery}%
      }
      \strng{namehash}{609a39905dc0e988c3b294dceecdb1e4}
      \strng{fullhash}{609a39905dc0e988c3b294dceecdb1e4}
      \strng{bibnamehash}{609a39905dc0e988c3b294dceecdb1e4}
      \strng{authorbibnamehash}{609a39905dc0e988c3b294dceecdb1e4}
      \strng{authornamehash}{609a39905dc0e988c3b294dceecdb1e4}
      \strng{authorfullhash}{609a39905dc0e988c3b294dceecdb1e4}
      \field{sortinit}{C}
      \field{sortinithash}{4d103a86280481745c9c897c925753c0}
      \field{labelnamesource}{author}
      \field{labeltitlesource}{title}
      \field{abstract}{It is shown that any recognition problem solved by a polynomial time-bounded nondeterministic Turing machine can be âreducedâ to the problem of determining whether a given propositional formula is a tautology. Here âreducedâ means, roughly speaking, that the first problem can be solved deterministically in polynomial time provided an oracle is available for solving the second. From this notion of reducible, polynomial degrees of difficulty are defined, and it is shown that the problem of determining tautologyhood has the same polynomial degree as the problem of determining whether the first of two given graphs is isomorphic to a subgraph of the second. Other examples are discussed. A method of measuring the complexity of proof procedures for the predicate calculus is introduced and discussed.}
      \field{booktitle}{Proceedings of the Third Annual ACM Symposium on Theory of Computing}
      \field{isbn}{9781450374644}
      \field{series}{STOC '71}
      \field{title}{The complexity of theorem-proving procedures}
      \field{year}{1971}
      \field{pages}{151\bibrangedash 158}
      \range{pages}{8}
      \verb{doi}
      \verb 10.1145/800157.805047
      \endverb
      \verb{urlraw}
      \verb https://doi.org/10.1145/800157.805047
      \endverb
      \verb{url}
      \verb https://doi.org/10.1145/800157.805047
      \endverb
    \endentry
    \entry{10.1007/978-3-031-13185-1_2}{inproceedings}{}
      \name{author}{1}{}{%
        {{hash=b6a85aabf982fa0236b58eb6b9f2ce66}{%
           family={Gurfinkel},
           familyi={G\bibinitperiod},
           given={Arie},
           giveni={A\bibinitperiod}}}%
      }
      \name{editor}{2}{}{%
        {{hash=9123c2f21c3c72bbeb5d7aa3db1d89bf}{%
           family={Shoham},
           familyi={S\bibinitperiod},
           given={Sharon},
           giveni={S\bibinitperiod}}}%
        {{hash=35b1b487afe69d81201029bd40df55e2}{%
           family={Vizel},
           familyi={V\bibinitperiod},
           given={Yakir},
           giveni={Y\bibinitperiod}}}%
      }
      \list{location}{1}{%
        {Cham}%
      }
      \list{publisher}{1}{%
        {Springer International Publishing}%
      }
      \strng{namehash}{b6a85aabf982fa0236b58eb6b9f2ce66}
      \strng{fullhash}{b6a85aabf982fa0236b58eb6b9f2ce66}
      \strng{bibnamehash}{b6a85aabf982fa0236b58eb6b9f2ce66}
      \strng{authorbibnamehash}{b6a85aabf982fa0236b58eb6b9f2ce66}
      \strng{authornamehash}{b6a85aabf982fa0236b58eb6b9f2ce66}
      \strng{authorfullhash}{b6a85aabf982fa0236b58eb6b9f2ce66}
      \strng{editorbibnamehash}{27b07f66c87a1fd4be2290d7f05a534a}
      \strng{editornamehash}{27b07f66c87a1fd4be2290d7f05a534a}
      \strng{editorfullhash}{27b07f66c87a1fd4be2290d7f05a534a}
      \field{sortinit}{G}
      \field{sortinithash}{32d67eca0634bf53703493fb1090a2e8}
      \field{labelnamesource}{author}
      \field{labeltitlesource}{title}
      \field{abstract}{Many problems in program verification, Model Checking, and type inference are naturally expressed as satisfiability of a verification condition expressed in a fragment of First-Order Logic called Constrained Horn Clauses (CHC). This transforms program analysis and verification tasks to the realm of first order satisfiability and into the realm of SMT solvers. In this paper, we give a brief overview of how CHCs capture verification problems for sequential imperative programs, and discuss CHC solving algorithm underlying the Spacer engine of SMT-solver Z3.}
      \field{booktitle}{Computer Aided Verification}
      \field{isbn}{978-3-031-13185-1}
      \field{title}{Program Verification withÂ Constrained Horn Clauses (Invited Paper)}
      \field{year}{2022}
      \field{pages}{19\bibrangedash 29}
      \range{pages}{11}
    \endentry
    \entry{10.1007/978-3-319-40970-2_35}{inproceedings}{}
      \name{author}{4}{}{%
        {{hash=69e1b961a056c36239ef9dd4b0dcb210}{%
           family={HyvÃ¤rinen},
           familyi={H\bibinitperiod},
           given={Antti\bibnamedelimb E.\bibnamedelimi J.},
           giveni={A\bibinitperiod\bibinitdelim E\bibinitperiod\bibinitdelim J\bibinitperiod}}}%
        {{hash=d94f8715668a901f22f10d6595362d64}{%
           family={Marescotti},
           familyi={M\bibinitperiod},
           given={Matteo},
           giveni={M\bibinitperiod}}}%
        {{hash=6c1bb2025f3bd26ba76e2a040dfffc50}{%
           family={Alt},
           familyi={A\bibinitperiod},
           given={Leonardo},
           giveni={L\bibinitperiod}}}%
        {{hash=1f57d7602abbd1e09505b9760b4a5a8b}{%
           family={Sharygina},
           familyi={S\bibinitperiod},
           given={Natasha},
           giveni={N\bibinitperiod}}}%
      }
      \name{editor}{2}{}{%
        {{hash=dc9f61df867eb144e9018fc6124e65b3}{%
           family={Creignou},
           familyi={C\bibinitperiod},
           given={Nadia},
           giveni={N\bibinitperiod}}}%
        {{hash=124a9c7eb40b2fb42da88f6661060f7b}{%
           family={Le\bibnamedelima Berre},
           familyi={L\bibinitperiod\bibinitdelim B\bibinitperiod},
           given={Daniel},
           giveni={D\bibinitperiod}}}%
      }
      \list{location}{1}{%
        {Cham}%
      }
      \list{publisher}{1}{%
        {Springer International Publishing}%
      }
      \strng{namehash}{c80cd845e24d7afff06b607c3336ab40}
      \strng{fullhash}{ebae9e26c823cba31da1a382ac29c582}
      \strng{bibnamehash}{ebae9e26c823cba31da1a382ac29c582}
      \strng{authorbibnamehash}{ebae9e26c823cba31da1a382ac29c582}
      \strng{authornamehash}{c80cd845e24d7afff06b607c3336ab40}
      \strng{authorfullhash}{ebae9e26c823cba31da1a382ac29c582}
      \strng{editorbibnamehash}{2a666c185400a82c4bcb711c3b66cd36}
      \strng{editornamehash}{2a666c185400a82c4bcb711c3b66cd36}
      \strng{editorfullhash}{2a666c185400a82c4bcb711c3b66cd36}
      \field{sortinit}{H}
      \field{sortinithash}{23a3aa7c24e56cfa16945d55545109b5}
      \field{labelnamesource}{author}
      \field{labeltitlesource}{title}
      \field{abstract}{This paper describes a major revision of the OpenSMT solver developed since 2008. The version 2 significantly improves its predecessor by providing a design that supports extensions, several critical bug fixes and performance improvements. The distinguishing feature of the new version is the support for a wide range of parallelization algorithms both on multi-core and cloud-computing environments. Presently the solver implements the quantifier free theories of uninterpreted functions and equalities and linear real arithmetics, and is released under the MIT license.}
      \field{booktitle}{Theory and Applications of Satisfiability Testing -- SAT 2016}
      \field{isbn}{978-3-319-40970-2}
      \field{title}{OpenSMT2: An SMT Solver for Multi-core and Cloud Computing}
      \field{year}{2016}
      \field{pages}{547\bibrangedash 553}
      \range{pages}{7}
    \endentry
    \entry{7886665}{inproceedings}{}
      \name{author}{2}{}{%
        {{hash=3712e5b18594a81449956230f1ca0a13}{%
           family={JovanoviÄ},
           familyi={J\bibinitperiod},
           given={Dejan},
           giveni={D\bibinitperiod}}}%
        {{hash=0908582acb17105e7b66314c508d1376}{%
           family={Dutertre},
           familyi={D\bibinitperiod},
           given={Bruno},
           giveni={B\bibinitperiod}}}%
      }
      \strng{namehash}{fdca7f078bd4bff51913ff7579f01723}
      \strng{fullhash}{fdca7f078bd4bff51913ff7579f01723}
      \strng{bibnamehash}{fdca7f078bd4bff51913ff7579f01723}
      \strng{authorbibnamehash}{fdca7f078bd4bff51913ff7579f01723}
      \strng{authornamehash}{fdca7f078bd4bff51913ff7579f01723}
      \strng{authorfullhash}{fdca7f078bd4bff51913ff7579f01723}
      \field{sortinit}{J}
      \field{sortinithash}{b2f54a9081ace9966a7cb9413811edb4}
      \field{labelnamesource}{author}
      \field{labeltitlesource}{title}
      \field{booktitle}{2016 Formal Methods in Computer-Aided Design (FMCAD)}
      \field{title}{Property-directed k-induction}
      \field{year}{2016}
      \field{pages}{85\bibrangedash 92}
      \range{pages}{8}
      \verb{doi}
      \verb 10.1109/FMCAD.2016.7886665
      \endverb
      \keyw{Interpolation;Cognition;Writing;Software;Concrete;Algorithm design and analysis;Adaptation models}
    \endentry
    \entry{10.1007/978-3-319-08867-9_2}{inproceedings}{}
      \name{author}{3}{}{%
        {{hash=7690c9f5fe24e031e30ac578548f16b8}{%
           family={Komuravelli},
           familyi={K\bibinitperiod},
           given={Anvesh},
           giveni={A\bibinitperiod}}}%
        {{hash=b6a85aabf982fa0236b58eb6b9f2ce66}{%
           family={Gurfinkel},
           familyi={G\bibinitperiod},
           given={Arie},
           giveni={A\bibinitperiod}}}%
        {{hash=64278473608517c3973009c0a20fb765}{%
           family={Chaki},
           familyi={C\bibinitperiod},
           given={Sagar},
           giveni={S\bibinitperiod}}}%
      }
      \name{editor}{2}{}{%
        {{hash=22081d00e30965a89f413e528510617e}{%
           family={Biere},
           familyi={B\bibinitperiod},
           given={Armin},
           giveni={A\bibinitperiod}}}%
        {{hash=9865af1b742410e6dee8ca813e1ec733}{%
           family={Bloem},
           familyi={B\bibinitperiod},
           given={Roderick},
           giveni={R\bibinitperiod}}}%
      }
      \list{location}{1}{%
        {Cham}%
      }
      \list{publisher}{1}{%
        {Springer International Publishing}%
      }
      \strng{namehash}{b26d50236d410994f79dfa8685ee28ae}
      \strng{fullhash}{3d51bc46486c70b16552a51affcfff3c}
      \strng{bibnamehash}{3d51bc46486c70b16552a51affcfff3c}
      \strng{authorbibnamehash}{3d51bc46486c70b16552a51affcfff3c}
      \strng{authornamehash}{b26d50236d410994f79dfa8685ee28ae}
      \strng{authorfullhash}{3d51bc46486c70b16552a51affcfff3c}
      \strng{editorbibnamehash}{59cf8d18520d1b03e8e55b4a50cde2cb}
      \strng{editornamehash}{59cf8d18520d1b03e8e55b4a50cde2cb}
      \strng{editorfullhash}{59cf8d18520d1b03e8e55b4a50cde2cb}
      \field{sortinit}{K}
      \field{sortinithash}{c02bf6bff1c488450c352b40f5d853ab}
      \field{labelnamesource}{author}
      \field{labeltitlesource}{title}
      \field{abstract}{We present an SMT-based symbolic model checking algorithm for safety verification of recursive programs. The algorithm is modular and analyzes procedures individually. Unlike other SMT-based approaches, it maintains both over- and under-approximations of procedure summaries. Under-approximations are used to analyze procedure calls without inlining. Over-approximations are used to block infeasible counterexamples and detect convergence to a proof. We show that for programs and properties over a decidable theory, the algorithm is guaranteed to find a counterexample, if one exists. However, efficiency depends on an oracle for quantifier elimination (QE). For Boolean Programs, the algorithm is a polynomial decision procedure, matching the worst-case bounds of the best BDD-based algorithms. For Linear Arithmetic (integers and rationals), we give an efficient instantiation of the algorithm by applying QE lazily. We use existing interpolation techniques to over-approximate QE and introduce Model Based Projection to under-approximate QE. Empirical evaluation on SV-COMP benchmarks shows that our algorithm improves significantly on the state-of-the-art.}
      \field{booktitle}{Computer Aided Verification}
      \field{isbn}{978-3-319-08867-9}
      \field{title}{SMT-Based Model Checking for Recursive Programs}
      \field{year}{2014}
      \field{pages}{17\bibrangedash 34}
      \range{pages}{18}
    \endentry
    \entry{10.1007/978-3-540-45069-6_1}{inproceedings}{}
      \name{author}{1}{}{%
        {{hash=88f7b85ef2a816fa2b52cfff57905a87}{%
           family={McMillan},
           familyi={M\bibinitperiod},
           given={K.\bibnamedelimi L.},
           giveni={K\bibinitperiod\bibinitdelim L\bibinitperiod}}}%
      }
      \name{editor}{2}{}{%
        {{hash=aca78f563bd75e9a4176a9fee6c49504}{%
           family={Hunt},
           familyi={H\bibinitperiod},
           given={Warren\bibnamedelima A.},
           giveni={W\bibinitperiod\bibinitdelim A\bibinitperiod}}}%
        {{hash=ad8ab6fb6e98869ac8d0b96ea11ee519}{%
           family={Somenzi},
           familyi={S\bibinitperiod},
           given={Fabio},
           giveni={F\bibinitperiod}}}%
      }
      \list{location}{1}{%
        {Berlin, Heidelberg}%
      }
      \list{publisher}{1}{%
        {Springer Berlin Heidelberg}%
      }
      \strng{namehash}{88f7b85ef2a816fa2b52cfff57905a87}
      \strng{fullhash}{88f7b85ef2a816fa2b52cfff57905a87}
      \strng{bibnamehash}{88f7b85ef2a816fa2b52cfff57905a87}
      \strng{authorbibnamehash}{88f7b85ef2a816fa2b52cfff57905a87}
      \strng{authornamehash}{88f7b85ef2a816fa2b52cfff57905a87}
      \strng{authorfullhash}{88f7b85ef2a816fa2b52cfff57905a87}
      \strng{editorbibnamehash}{faeafc2da63b3c8a56ee184f42152091}
      \strng{editornamehash}{faeafc2da63b3c8a56ee184f42152091}
      \strng{editorfullhash}{faeafc2da63b3c8a56ee184f42152091}
      \field{extraname}{1}
      \field{sortinit}{M}
      \field{sortinithash}{4625c616857f13d17ce56f7d4f97d451}
      \field{labelnamesource}{author}
      \field{labeltitlesource}{title}
      \field{abstract}{We consider a fully SAT-based method of unbounded symbolic model checking based on computing Craig interpolants. In benchmark studies using a set of large industrial circuit verification instances, this method is greatly more efficient than BDD-based symbolic model checking, and compares favorably to some recent SAT-based model checking methods on positive instances.}
      \field{booktitle}{Computer Aided Verification}
      \field{isbn}{978-3-540-45069-6}
      \field{title}{Interpolation and SAT-Based Model Checking}
      \field{year}{2003}
      \field{pages}{1\bibrangedash 13}
      \range{pages}{13}
    \endentry
    \entry{10.1007/11817963_14}{inproceedings}{}
      \name{author}{1}{}{%
        {{hash=3616d5a3016d57a66323bf8a08013af1}{%
           family={McMillan},
           familyi={M\bibinitperiod},
           given={Kenneth\bibnamedelima L.},
           giveni={K\bibinitperiod\bibinitdelim L\bibinitperiod}}}%
      }
      \name{editor}{2}{}{%
        {{hash=7f93be3bfac6f3c9c63f0897c6518329}{%
           family={Ball},
           familyi={B\bibinitperiod},
           given={Thomas},
           giveni={T\bibinitperiod}}}%
        {{hash=db11c90f71c6b308fbe226ff13722594}{%
           family={Jones},
           familyi={J\bibinitperiod},
           given={Robert\bibnamedelima B.},
           giveni={R\bibinitperiod\bibinitdelim B\bibinitperiod}}}%
      }
      \list{location}{1}{%
        {Berlin, Heidelberg}%
      }
      \list{publisher}{1}{%
        {Springer Berlin Heidelberg}%
      }
      \strng{namehash}{3616d5a3016d57a66323bf8a08013af1}
      \strng{fullhash}{3616d5a3016d57a66323bf8a08013af1}
      \strng{bibnamehash}{3616d5a3016d57a66323bf8a08013af1}
      \strng{authorbibnamehash}{3616d5a3016d57a66323bf8a08013af1}
      \strng{authornamehash}{3616d5a3016d57a66323bf8a08013af1}
      \strng{authorfullhash}{3616d5a3016d57a66323bf8a08013af1}
      \strng{editorbibnamehash}{db864e5e454416b7f140413787172c0e}
      \strng{editornamehash}{db864e5e454416b7f140413787172c0e}
      \strng{editorfullhash}{db864e5e454416b7f140413787172c0e}
      \field{extraname}{2}
      \field{sortinit}{M}
      \field{sortinithash}{4625c616857f13d17ce56f7d4f97d451}
      \field{labelnamesource}{author}
      \field{labeltitlesource}{title}
      \field{abstract}{We describe a model checker for infinite-state sequential programs, based on Craig interpolation and the lazy abstraction paradigm. On device driver benchmarks, we observe a speedup of up to two orders of magnitude relative to a similar tool using predicate abstraction.}
      \field{booktitle}{Computer Aided Verification}
      \field{isbn}{978-3-540-37411-4}
      \field{title}{Lazy Abstraction with Interpolants}
      \field{year}{2006}
      \field{pages}{123\bibrangedash 136}
      \range{pages}{14}
    \endentry
    \entry{10.1007/3-540-40922-X_8}{inproceedings}{}
      \name{author}{3}{}{%
        {{hash=fe2ee529e16c31190e661b36efccfc55}{%
           family={Sheeran},
           familyi={S\bibinitperiod},
           given={Mary},
           giveni={M\bibinitperiod}}}%
        {{hash=3f6e8aff1229dbdd35422df96547cfde}{%
           family={Singh},
           familyi={S\bibinitperiod},
           given={Satnam},
           giveni={S\bibinitperiod}}}%
        {{hash=b706a17fcd44ddbb407b43f46f1c9bbb}{%
           family={St{Ã¥}lmarck},
           familyi={S\bibinitperiod},
           given={Gunnar},
           giveni={G\bibinitperiod}}}%
      }
      \name{editor}{2}{}{%
        {{hash=aca78f563bd75e9a4176a9fee6c49504}{%
           family={Hunt},
           familyi={H\bibinitperiod},
           given={Warren\bibnamedelima A.},
           giveni={W\bibinitperiod\bibinitdelim A\bibinitperiod}}}%
        {{hash=eafbe2efecc792544999f129f2794b95}{%
           family={Johnson},
           familyi={J\bibinitperiod},
           given={Steven\bibnamedelima D.},
           giveni={S\bibinitperiod\bibinitdelim D\bibinitperiod}}}%
      }
      \list{location}{1}{%
        {Berlin, Heidelberg}%
      }
      \list{publisher}{1}{%
        {Springer Berlin Heidelberg}%
      }
      \strng{namehash}{5db240ef59767ea4694d0c6da6a4a544}
      \strng{fullhash}{2658a818953876e7021e404ceaf37b1a}
      \strng{bibnamehash}{2658a818953876e7021e404ceaf37b1a}
      \strng{authorbibnamehash}{2658a818953876e7021e404ceaf37b1a}
      \strng{authornamehash}{5db240ef59767ea4694d0c6da6a4a544}
      \strng{authorfullhash}{2658a818953876e7021e404ceaf37b1a}
      \strng{editorbibnamehash}{3af5090c14076e9b478068169e5b1478}
      \strng{editornamehash}{3af5090c14076e9b478068169e5b1478}
      \strng{editorfullhash}{3af5090c14076e9b478068169e5b1478}
      \field{sortinit}{S}
      \field{sortinithash}{b164b07b29984b41daf1e85279fbc5ab}
      \field{labelnamesource}{author}
      \field{labeltitlesource}{title}
      \field{abstract}{We take a fresh look at the problem of how to check safety properties of finite state machines. We are particularly interested in checking safety properties with the help of a SAT-solver. We describe some novel induction-based methods, and show how they are related to more standard fixpoint algorithms for invariance checking. We also present preliminary experimental results in the verification of FPGA cores. This demonstrates the practicality of combining a SAT-solver with induction for safety property checking of hardware in a real design flow.}
      \field{booktitle}{Formal Methods in Computer-Aided Design}
      \field{isbn}{978-3-540-40922-9}
      \field{title}{Checking Safety Properties Using Induction and a SAT-Solver}
      \field{year}{2000}
      \field{pages}{127\bibrangedash 144}
      \range{pages}{18}
    \endentry
    \entry{6148908}{inproceedings}{}
      \name{author}{2}{}{%
        {{hash=ad8ab6fb6e98869ac8d0b96ea11ee519}{%
           family={Somenzi},
           familyi={S\bibinitperiod},
           given={Fabio},
           giveni={F\bibinitperiod}}}%
        {{hash=3b7ddc315169b6c8cbd722f70828be9b}{%
           family={Bradley},
           familyi={B\bibinitperiod},
           given={Aaron\bibnamedelima R.},
           giveni={A\bibinitperiod\bibinitdelim R\bibinitperiod}}}%
      }
      \strng{namehash}{29fc03c74cecbf1d2ab6c913aa05b4e4}
      \strng{fullhash}{29fc03c74cecbf1d2ab6c913aa05b4e4}
      \strng{bibnamehash}{29fc03c74cecbf1d2ab6c913aa05b4e4}
      \strng{authorbibnamehash}{29fc03c74cecbf1d2ab6c913aa05b4e4}
      \strng{authornamehash}{29fc03c74cecbf1d2ab6c913aa05b4e4}
      \strng{authorfullhash}{29fc03c74cecbf1d2ab6c913aa05b4e4}
      \field{sortinit}{S}
      \field{sortinithash}{b164b07b29984b41daf1e85279fbc5ab}
      \field{labelnamesource}{author}
      \field{labeltitlesource}{title}
      \field{booktitle}{2011 Formal Methods in Computer-Aided Design (FMCAD)}
      \field{title}{IC3: Where monolithic and incremental meet}
      \field{year}{2011}
      \field{pages}{3\bibrangedash 8}
      \range{pages}{6}
      \keyw{Safety;Computational modeling;Data structures;Boolean functions;Context;Approximation methods;Encoding}
    \endentry
  \enddatalist
\endrefsection
\endinput

